---
**Explicación Detallada del Funcionamiento de NextAuth.js en el Proyecto**

NextAuth.js es una librería completa de autenticación para aplicaciones Next.js. En tu proyecto, se utiliza para gestionar el inicio de sesión de usuarios, el registro (implícito a través de proveedores o explícito si lo implementaras), y el manejo de sesiones.

**1. Archivos Clave de Configuración:**

*   **`auth.ts` (Principal):** Este archivo contiene la configuración central de NextAuth.js. Define:
    *   **Adaptador (Adapter):** `PrismaAdapter` se utiliza para conectar NextAuth.js con tu base de datos Prisma. Esto permite que NextAuth.js cree y actualice usuarios, cuentas, sesiones, etc., directamente en tu base de datos MySQL.
        *   **`customAdapter`:** Has personalizado el adaptador, especialmente la función `createUser`. Esta personalización es clave para tu flujo:
            *   Para usuarios que se registran/ingresan vía un proveedor OAuth (como Google), que no proporcionan una contraseña directamente, tu código genera una contraseña temporal segura (hasheada con bcrypt) y establece un indicador `needsPasswordChange = true` en la base de datos para ese usuario.
            *   También asegura que `emailVerified` se marque como verdadero si el proveedor OAuth confirma la verificación.
    *   **Proveedores (Providers):**
        *   **Google:** Permite a los usuarios iniciar sesión con sus cuentas de Google. La configuración incluye `clientId` y `clientSecret`. El callback `profile` se usa para mapear los datos del perfil de Google a la estructura de tu modelo `User` en Prisma, generando un `username` único y marcando el email como verificado.
        *   **Credentials:** Permite el inicio de sesión tradicional con email y contraseña. El callback `authorize` es fundamental aquí:
            *   Valida los datos de entrada usando un esquema Zod (`loginSchema`).
            *   Busca al usuario en la base de datos por email.
            *   Compara la contraseña proporcionada con la contraseña hasheada almacenada en la base de datos usando `bcrypt.js`.
            *   En un entorno de producción, verifica si el email del usuario ha sido verificado. Si no, impide el inicio de sesión y puede lanzar un error `email_not_verified`.
            *   Incluye una lógica para "auto-verificación" que permite el inicio de sesión sin contraseña si se proporcionan credenciales especiales (probablemente después de que un usuario haga clic en un enlace de verificación de email).
            *   Si la autenticación es exitosa, genera un JSON Web Token (JWT) interno (`accessToken`) que contiene `userId`, `role`, y `username`. Este token se adjunta al objeto `user` que NextAuth.js luego usa.
    *   **Estrategia de Sesión:** Se configura como `"jwt"`. Esto significa que la información de la sesión del usuario se almacena en un JWT que se envía al cliente (generalmente como una cookie HTTP-only segura) en lugar de almacenar la sesión en la base de datos.
    *   **Páginas (Pages):** Define rutas personalizadas para páginas como `signIn` (`/api/auth/signin`, que es la página por defecto de NextAuth o una tuya si la personalizas ahí) y `error` (`/auth/error`).
    *   **Callbacks:** Son funciones que te permiten personalizar el comportamiento de NextAuth.js en ciertos puntos del ciclo de vida de la autenticación:
        *   **`signIn`:** Se ejecuta cuando un usuario intenta iniciar sesión. Para Google, te aseguras de que si el perfil de Google indica que el email está verificado, tu base de datos local refleje esto.
        *   **`jwt`:** Es crucial para la estrategia de sesión JWT. Se ejecuta cada vez que se crea o actualiza un JWT. Aquí es donde enriqueces el token JWT con la información que necesitas del usuario (ID, rol, nombre, email, username, `needsPasswordChange`, `emailVerified`, `accessToken` generado en `authorize`, etc.). También manejas la actualización manual de la sesión (`trigger === "update"`).
        *   **`session`:** Se ejecuta cada vez que se accede a una sesión (ej. con `useSession` en el cliente o `auth()` en el servidor). Toma los datos del token JWT y los estructura en el objeto `session.user` que tu aplicación utilizará.

*   **`src/app/api/auth/[...nextauth]/route.ts`:** Este es el "catch-all route handler" que expone todos los endpoints necesarios para NextAuth.js (ej. `/api/auth/signin`, `/api/auth/callback/google`, `/api/auth/signout`, etc.). Simplemente importa y exporta los `handlers` (GET y POST) de tu archivo `auth.ts`.

*   **`middleware.ts`:** Este archivo es fundamental para proteger rutas y gestionar el acceso.
    *   Se ejecuta para las rutas definidas en su `matcher`.
    *   Obtiene el token JWT del usuario actual usando `getToken`.
    *   **Protección de Rutas:**
        *   Si no hay token (usuario no autenticado) y la ruta no es pública, redirige a la página de inicio de sesión (`/api/auth/signin`) guardando la URL original para redirigir de vuelta tras el login (`callbackUrl`).
        *   **`needsPasswordChange`:** Si el token del usuario indica `needsPasswordChange === true` (típicamente para usuarios de OAuth que aún no han configurado una contraseña local), y el usuario no está ya en la página `/setup-password`, el middleware lo redirige a `/setup-password`.
        *   **Verificación de Email:** Si el email del usuario no está verificado (`!token.emailVerified`) y la ruta actual no es una de las permitidas para usuarios no verificados (como la página que le dice "verifica tu email" o la API para reenviar el email de verificación), lo redirige a `/auth/verification-pending`.
        *   **Acceso de Administrador:** Si el usuario intenta acceder a una ruta que comienza con `/admin` y su rol no es `admin`, lo redirige a `/acceso-denegado`.
    *   Define una lista de rutas y patrones públicos que no requieren autenticación.

**2. Flujo de Autenticación (Ejemplo: Inicio de Sesión con Credenciales):**

1.  **Usuario:** Navega a tu página de inicio de sesión (o es redirigido allí por el middleware).
2.  **Frontend:** El usuario ingresa su email y contraseña. Al enviar el formulario, el cliente llama a la función `signIn("credentials", { email, password, redirect: false })` proporcionada por NextAuth.js.
3.  **NextAuth.js (Cliente):** Envía una petición POST a `/api/auth/signin/credentials`.
4.  **NextAuth.js (Servidor - `route.ts` y `auth.ts`):**
    *   El manejador en `route.ts` pasa la petición al `handlers.POST` de `auth.ts`.
    *   Se activa el proveedor `Credentials`.
    *   La función `authorize` en `auth.ts` se ejecuta:
        *   Valida los datos.
        *   Busca el usuario en Prisma.
        *   Compara la contraseña hasheada con `bcrypt.js`.
        *   Verifica si el email está confirmado (en producción).
        *   Si todo es correcto, devuelve el objeto `user` (incluyendo el `accessToken` que generaste). Si falla, devuelve `null` o lanza un error.
5.  **NextAuth.js (Servidor - Callbacks):**
    *   Si `authorize` fue exitoso, se ejecuta el callback `signIn` (devuelve `true` para permitir).
    *   Luego se ejecuta el callback `jwt`. Se crea un JWT con los datos del usuario (ID, rol, email, `needsPasswordChange`, etc.).
    *   NextAuth.js establece una cookie HTTP-only segura que contiene este JWT.
6.  **Respuesta al Cliente:**
    *   Si `redirect: false` no se usó, NextAuth.js redirige al `callbackUrl` o a la página por defecto. Si se usó, devuelve un JSON con el resultado del inicio de sesión.
7.  **Acceso a la Sesión:**
    *   **Cliente:** El hook `useSession()` puede usarse en componentes React para acceder a los datos de la sesión. Este hook hace una petición a `/api/auth/session` (manejada por NextAuth.js).
    *   **Servidor (API Routes, `getServerSideProps`):** La función `auth()` (o `getServerSession(authOptions)`) puede usarse para obtener la sesión.
    *   En ambos casos, NextAuth.js valida el JWT de la cookie, y si es válido, el callback `session` en `auth.ts` se ejecuta para dar forma al objeto `session` que se devuelve a la aplicación.

**3. Flujo de Autenticación (Ejemplo: Inicio de Sesión con Google):**

1.  **Usuario:** Hace clic en "Iniciar sesión con Google".
2.  **Frontend:** Llama a `signIn("google")`.
3.  **NextAuth.js:** Redirige al usuario a la página de consentimiento de Google.
4.  **Google:** El usuario autoriza la aplicación. Google redirige de vuelta a tu aplicación a la URL de callback (ej. `/api/auth/callback/google`) con un código de autorización.
5.  **NextAuth.js (Servidor):**
    *   El manejador de callback para Google intercambia el código por tokens de acceso y perfil de Google.
    *   Se ejecuta el callback `profile` en la configuración del proveedor Google en `auth.ts` para mapear los datos del perfil de Google a tu formato de usuario.
    *   El `PrismaAdapter` (con tu `customAdapter`) se encarga de:
        *   Buscar si el usuario ya existe en tu BD por email.
        *   Si existe, lo actualiza (si es necesario).
        *   Si no existe, lo crea. Aquí es donde tu `customAdapter` entra en juego: genera la contraseña temporal hasheada y establece `needsPasswordChange = true`.
    *   Se ejecutan los callbacks `signIn` y `jwt` como en el flujo de credenciales, creando el JWT y la cookie de sesión.
6.  **Redirección y Middleware:**
    *   El usuario es redirigido.
    *   El `middleware.ts` se ejecuta. Detecta que `needsPasswordChange` es `true` en el token JWT del usuario.
    *   Redirige al usuario a la página `/setup-password` para que establezca una contraseña local.

**4. Protección de Rutas y API:**

*   El `middleware.ts` es la primera línea de defensa, como se describió antes.
*   En las API Routes del backend (si no están cubiertas genéricamente por el middleware), puedes usar `const session = await auth();` al principio de tu manejador para obtener la sesión. Si no hay sesión o el usuario no tiene los permisos necesarios, puedes devolver un error 401 o 403.

Este sistema te proporciona una autenticación robusta y flexible, bien integrada con tu base de datos y con flujos específicos como el de forzar el establecimiento de contraseña para usuarios de OAuth.
---
